#!/usr/bin/env bash
#set -euo pipefail
IFS=$'\t\n'

help_format="  %-3s %-20s %s\n"
help_format_1="  $help_format"
wsh_dir=$(dirname $(realpath "$0"))
plugin_dir="$wsh_dir/plugins"

args=()
flags=()

# FLAGS
debug=
init=
init_pyenv=
init_nvm=
shell_sync=

stdout() {
    printf '%s\n' "$@"
}

log() {
    printf "%s\n" "$@" >&2 
}

debug(){
    if [[ -n $debug ]]; then
        log "v: $@"
    fi
}

to_array() {
    local arr_name=$1
    shift # first arg is the arr name, so let's ignore it from now on
    IFS=$'\n' read -r -d '' -a $arr_name <<< "$*" || true
}


usage() {
    log ""
    log "usage: $(basename $0) OPERATION [...]"
    log ""
    log "some OPTIONS enter a context and will allow the use of more OPTIONS, but whenever an OPTION from outside this context is passed, then it leaves the context, meaning that the order of OPTIONS is semi-important"
    log "examples:"
    log " wsh -Ipv"
    log " wsh -vIp"
    log ""
    log "bad examples:"
    log " wsh -Ivp # -v breaks the -I context, making -p no longer relevant"
    log ""
    printf $help_format "-h" "--help" "show this menu"
    printf $help_format "-v" "--vebose" "extensive logging"
    printf $help_format "-I" "--init" "init options"
    printf $help_format_1 "-n" "--nvm" "init nvm"
    printf $help_format_1 "-p" "--pyenv" "init pyenv"
    printf $help_format "-S" "--shell" "shell options"
    printf $help_format_1 "-S" "--sync" "sync a package, which will install or update a package"
}

pre_process_flags() {
    for arg in "$@"; do
        case "$arg" in 
            --*)
                stdout "$arg"
                ;;
            -*)
                for ((i=1; i<${#arg}; i++)); do
                    stdout "-${arg:i:1}"
                done
                ;;
            *)
                stdout "$arg"
                ;;
        esac
    done
}

unknown_flag() {
    log "unknown argument: $1"
    log "mayhaps it was used in the wrong context?"
    usage
    exit 1
}

count_ops() {
    local -a arr_name=$1
    shift
    local -a temp
    count=0
    for op in "$@"; do
        if [[ ${!op} ]]; then
            ((count++))
            temp+=("$op")
        fi
    done
    eval "$arr_name=(\"\${temp[@]}\")"
    return $count
}

if [[ ${#@} -eq 0 ]]; then
    usage
    exit 1
fi

to_array flags "$(pre_process_flags "$@")"

for ((i = 0 ; i < "${#flags[@]}" ; i++ )); do
    case "${flags[$i]}" in
        --help | -h)
            usage
            exit 0
            ;;
        --verbose | -v)
            debug=1
            ;;
        --init | -I)
            init=1
            ((i++)) || true
            for (( ; i < "${#flags[@]}" ; i++ )); do
                case "${flags[$i]}" in 
                    --pyenv | -p)
                        init_pyenv=1
                        ;;
                    --nvm | -n)
                        init_nvm=1
                        ;;
                    *)
                        ((i--)) || true
                        break
                        ;;
                esac
            done
            ;;
        --shell | -S)
            ((i++)) || true
            for (( ; i < "${#flags[@]}" ; i++ )); do
                case "${flags[$i]}" in 
                    --sync | -S)
                        shell_sync=1
                        ;;
                    *)
                        ((i--)) || true
                        break
                        ;;
                esac done
            ;;
        --* | -*)
            unknown_flag "${flags[i]}"
            exit 1
            ;;
        *)
            args+=("${flags[$i]}")
            ;;
    esac
done

# ADD MORE OPS HERE
count_ops ops init shell_sync
op_count=$?

if [[ $op_count -eq 0 ]]; then
    log "no operation defined"
    usage
    exit 1
elif [[ $op_count -gt 1 ]]; then
    log "more than 1 operation defined: " ${ops[@]}
    usage
    exit 1
fi

if [[ -n $init ]]; then
    debug "initializing autocompletions"
    echo "autoload -Uz compinit"
    echo "compinit"
    echo "eval $(starship init zsh)"
fi

if [[ -n $init_pyenv ]]; then
    debug "initializing pyenv"
    echo "source $wsh_dir/_pyenv.sh"
fi

if [[ -n $init_nvm ]]; then 
    debug "initializing nvm"
    echo "source $wsh_dir/_nvm.sh"
fi

if [[ -n $shell_sync ]]; then
    debug "syncing packages"
    for pkg in "${args[@]}"; do
        echo $pkg
    done
fi
